import { Directive, Input, ElementRef, ViewContainerRef, Renderer, ChangeDetectorRef, ComponentFactoryResolver, forwardRef, EventEmitter, Output, HostListener } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { NgxMyDatePicker } from "./ngx-my-date-picker.component";
import { UtilService } from "./services/ngx-my-date-picker.util.service";
var NGX_DP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return NgxMyDatePickerDirective; }),
    multi: true
};
var CalToggle;
(function (CalToggle) {
    CalToggle[CalToggle["Open"] = 1] = "Open";
    CalToggle[CalToggle["CloseByDateSel"] = 2] = "CloseByDateSel";
    CalToggle[CalToggle["CloseByCalBtn"] = 3] = "CloseByCalBtn";
    CalToggle[CalToggle["CloseByOutClick"] = 4] = "CloseByOutClick";
    CalToggle[CalToggle["CloseByEsc"] = 5] = "CloseByEsc";
})(CalToggle || (CalToggle = {}));
var Year;
(function (Year) {
    Year[Year["min"] = 1100] = "min";
    Year[Year["max"] = 9100] = "max";
})(Year || (Year = {}));
var KeyCode;
(function (KeyCode) {
    KeyCode[KeyCode["esc"] = 27] = "esc";
    KeyCode[KeyCode["leftArrow"] = 37] = "leftArrow";
    KeyCode[KeyCode["rightArrow"] = 39] = "rightArrow";
})(KeyCode || (KeyCode = {}));
export var NgxMyDatePickerDirective = (function () {
    function NgxMyDatePickerDirective(utilService, vcRef, cfr, renderer, cdr, elem) {
        this.utilService = utilService;
        this.vcRef = vcRef;
        this.cfr = cfr;
        this.renderer = renderer;
        this.cdr = cdr;
        this.elem = elem;
        this.dateChanged = new EventEmitter();
        this.inputFieldChanged = new EventEmitter();
        this.calendarViewChanged = new EventEmitter();
        this.calendarToggle = new EventEmitter();
        this.cRef = null;
        this.inputText = "";
        this.preventClose = false;
        this.opts = {
            dayLabels: { su: "Sun", mo: "Mon", tu: "Tue", we: "Wed", th: "Thu", fr: "Fri", sa: "Sat" },
            monthLabels: { 1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun", 7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec" },
            dateFormat: "yyyy-mm-dd",
            showTodayBtn: true,
            todayBtnTxt: "Today",
            firstDayOfWeek: "mo",
            sunHighlight: true,
            markCurrentDay: true,
            monthSelector: true,
            yearSelector: true,
            disableHeaderButtons: true,
            showWeekNumbers: false,
            disableUntil: { year: 0, month: 0, day: 0 },
            disableSince: { year: 0, month: 0, day: 0 },
            disableDates: [],
            enableDates: [],
            markDates: [],
            markWeekends: {},
            disableDateRanges: [],
            disableWeekends: false,
            alignSelectorRight: false,
            openSelectorTopOfInput: false,
            minYear: Year.min,
            maxYear: Year.max,
            showSelectorArrow: true,
            ariaLabelPrevMonth: "Previous Month",
            ariaLabelNextMonth: "Next Month",
            ariaLabelPrevYear: "Previous Year",
            ariaLabelNextYear: "Next Year",
        };
        this.onChangeCb = function () { };
        this.onTouchedCb = function () { };
    }
    NgxMyDatePickerDirective.prototype.onKeyUp = function (evt) {
        if (evt.keyCode === KeyCode.leftArrow || evt.keyCode === KeyCode.rightArrow) {
            return;
        }
        else if (evt.keyCode === KeyCode.esc) {
            this.closeSelector(CalToggle.CloseByEsc);
        }
        else {
            var date = this.utilService.isDateValid(this.elem.nativeElement.value, this.opts.dateFormat, this.opts.minYear, this.opts.maxYear, this.opts.disableUntil, this.opts.disableSince, this.opts.disableWeekends, this.opts.disableDates, this.opts.disableDateRanges, this.opts.monthLabels, this.opts.enableDates);
            if (date.day !== 0 && date.month !== 0 && date.year !== 0) {
                var dateModel = this.utilService.getDateModel(date, this.opts.dateFormat, this.opts.monthLabels);
                this.emitDateChanged(dateModel);
                this.updateModel(dateModel);
                this.emitInputFieldChanged(dateModel.formatted, true);
                this.closeSelector(CalToggle.CloseByDateSel);
            }
            else {
                if (this.inputText !== this.elem.nativeElement.value) {
                    if (this.elem.nativeElement.value === "") {
                        this.clearDate();
                    }
                    else {
                        this.onChangeCb("");
                        this.emitInputFieldChanged(this.elem.nativeElement.value, false);
                    }
                }
            }
            this.inputText = this.elem.nativeElement.value;
        }
    };
    NgxMyDatePickerDirective.prototype.onClick = function (evt) {
        if (!this.preventClose && evt.target && this.cRef !== null && this.elem.nativeElement !== evt.target && !this.cRef.location.nativeElement.contains(evt.target)) {
            this.closeSelector(CalToggle.CloseByOutClick);
        }
    };
    NgxMyDatePickerDirective.prototype.ngOnChanges = function (changes) {
        if (changes.hasOwnProperty("options")) {
            this.parseOptions(changes["options"].currentValue);
        }
        if (changes.hasOwnProperty("defaultMonth")) {
            this.defaultMonth = changes["defaultMonth"].currentValue;
        }
    };
    NgxMyDatePickerDirective.prototype.parseOptions = function (opts) {
        var _this = this;
        if (opts !== undefined) {
            Object.keys(opts).forEach(function (k) {
                _this.opts[k] = opts[k];
            });
        }
        if (this.opts.minYear < Year.min) {
            this.opts.minYear = Year.min;
        }
        if (this.opts.maxYear > Year.max) {
            this.opts.maxYear = Year.max;
        }
    };
    NgxMyDatePickerDirective.prototype.writeValue = function (value) {
        if (value && value["date"]) {
            var formatted = this.utilService.formatDate(value["date"], this.opts.dateFormat, this.opts.monthLabels);
            this.setInputValue(formatted);
            this.emitInputFieldChanged(formatted, true);
        }
        else if (value === "") {
            this.setInputValue("");
            this.emitInputFieldChanged("", false);
        }
    };
    NgxMyDatePickerDirective.prototype.registerOnChange = function (fn) {
        this.onChangeCb = fn;
    };
    NgxMyDatePickerDirective.prototype.registerOnTouched = function (fn) {
        this.onTouchedCb = fn;
    };
    NgxMyDatePickerDirective.prototype.openCalendar = function () {
        var _this = this;
        this.preventClose = true;
        this.cdr.detectChanges();
        if (this.cRef === null) {
            var cf = this.cfr.resolveComponentFactory(NgxMyDatePicker);
            this.cRef = this.vcRef.createComponent(cf);
            this.cRef.instance.initialize(this.opts, this.defaultMonth, this.elem.nativeElement.value, this.elem.nativeElement.offsetWidth, this.elem.nativeElement.offsetHeight, function (dm) {
                _this.emitDateChanged(dm);
                _this.updateModel(dm);
                _this.closeSelector(CalToggle.CloseByDateSel);
            }, function (cvc) {
                _this.emitCalendarChanged(cvc);
            }, function () {
                _this.closeSelector(CalToggle.CloseByEsc);
            });
            this.emitCalendarToggle(CalToggle.Open);
        }
        setTimeout(function () {
            _this.preventClose = false;
        }, 50);
    };
    NgxMyDatePickerDirective.prototype.closeCalendar = function () {
        this.closeSelector(CalToggle.CloseByCalBtn);
    };
    NgxMyDatePickerDirective.prototype.toggleCalendar = function () {
        if (this.cRef === null) {
            this.openCalendar();
        }
        else {
            this.closeSelector(CalToggle.CloseByCalBtn);
        }
    };
    NgxMyDatePickerDirective.prototype.clearDate = function () {
        this.emitDateChanged({ date: { year: 0, month: 0, day: 0 }, jsdate: null, formatted: "", epoc: 0 });
        this.emitInputFieldChanged("", false);
        this.onChangeCb("");
        this.setInputValue("");
        this.closeSelector(CalToggle.CloseByCalBtn);
    };
    NgxMyDatePickerDirective.prototype.closeSelector = function (reason) {
        if (this.cRef !== null) {
            this.vcRef.remove(this.vcRef.indexOf(this.cRef.hostView));
            this.cRef = null;
            this.emitCalendarToggle(reason);
        }
    };
    NgxMyDatePickerDirective.prototype.updateModel = function (model) {
        this.onChangeCb(model);
        this.setInputValue(model.formatted);
    };
    NgxMyDatePickerDirective.prototype.setInputValue = function (value) {
        this.inputText = value;
        this.renderer.setElementProperty(this.elem.nativeElement, "value", value);
    };
    NgxMyDatePickerDirective.prototype.emitDateChanged = function (dateModel) {
        this.dateChanged.emit(dateModel);
    };
    NgxMyDatePickerDirective.prototype.emitInputFieldChanged = function (value, valid) {
        this.inputFieldChanged.emit({ value: value, dateFormat: this.opts.dateFormat, valid: valid });
    };
    NgxMyDatePickerDirective.prototype.emitCalendarChanged = function (cvc) {
        this.calendarViewChanged.emit(cvc);
    };
    NgxMyDatePickerDirective.prototype.emitCalendarToggle = function (reason) {
        this.calendarToggle.emit(reason);
    };
    NgxMyDatePickerDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[ngx-mydatepicker]",
                    exportAs: "ngx-mydatepicker",
                    providers: [UtilService, NGX_DP_VALUE_ACCESSOR]
                },] },
    ];
    NgxMyDatePickerDirective.ctorParameters = [
        { type: UtilService, },
        { type: ViewContainerRef, },
        { type: ComponentFactoryResolver, },
        { type: Renderer, },
        { type: ChangeDetectorRef, },
        { type: ElementRef, },
    ];
    NgxMyDatePickerDirective.propDecorators = {
        'options': [{ type: Input },],
        'defaultMonth': [{ type: Input },],
        'dateChanged': [{ type: Output },],
        'inputFieldChanged': [{ type: Output },],
        'calendarViewChanged': [{ type: Output },],
        'calendarToggle': [{ type: Output },],
        'onKeyUp': [{ type: HostListener, args: ["keyup", ["$event"],] },],
        'onClick': [{ type: HostListener, args: ["document:click", ["$event"],] },],
    };
    return NgxMyDatePickerDirective;
}());
//# sourceMappingURL=ngx-my-date-picker.input.js.map